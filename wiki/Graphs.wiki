#labels GraphBuilder
=Graphs=

Graphs are a building block of many engine systems, thus we provide a wide range of tools to operate on them.

==Graph==

This is a representation of a mathematical graph.
It's compact and provides a range of algorithms that operate on it.

A graph has *nodes* and *edges*. Each of these can be a different type.
You can use privitive types side by side with classes.

*One exception* to this rule is the case when you want to use a structure as your edge - is that case you need to equip it with a conversion operator `operator Graph::Index()` defined.

So basically - an edge at its simplest form ( when you use an *int* to represent it for instance ) represents the index of target node it connects. If you want to add some additional info to the node, you need to create a structure with the forementioned conversion operator that will return the index of the end node, and then you can add whatever additional info you require.

Let's take an example - let's assume you want to create a graph, where you represent a tactical map - each of the nodes has a structure representing some tactical data, and each edge describes how expensive it is to move from one position to another:

{{{
struct TacticalData
{
   // put some applicable fields here
};

struct TravelCostEdge;
typedef Graph< TacticalData, SomeEdge > TacticalMapGraph;

struct TravelCostEdge
{
     int endIdx;
     int val;

     TravelCostEdge( int _endIdx, int _val ) : endIdx( _endIdx ), val( _val ) {}

     operator TacticalMapGraph::Index() const { return endIdx; }
};


TacticalMapGraph map;
}}}

We've just defined our first graph type.

The edge holds info what node it connects, and the forementioned *conversion operator* has to return that index.


Let's fill such a graph with data now:

{{{
TacticalMapGraph map;

// first, we need to add the nodes
map.addNode( TacticalData() );  // node 0
map.addNode( TacticalData() );  // node 1

// then - once we have the nodes, we can connect them with edges
map.connect( 0, SomeEdge( 1, 10 ) );

// we just connected edge 0 with edge 1, and assigned travel cost 10 to it
}}}

It may seem not very convenient and readable to spread the info about which nodes an edge connects between one method parameter and the edge constructor - valid point indeed.
It was made that way with performance in mind - this way can keep compact data structures inside a graph and resign from using polymorphism - at a cost of this small inconvenience.

==Algorithms==

Ok - so we have a graph. What next? Well - a graph on its own is just a bunch of numbers and doesn't help us much.

But when we start running algorithms on it, it quickly becomes a tool of choice when it comes to sorting and finding data quickly.

Here's a couple of algorithms that operate on a graph:

  * `GraphTopologicalSort` - on occasion you may want to flatten a graph structure. Such a need may arise if i.e. your graph nodes represent c++ files, and its edges represent dependencies between them, and you want to sort the files in such an order, that if you start compiling them, you won't run into a dependency problem. Then a *topological sort* is the tool you've been looking for.

  Here's a transcript from a unit test that shouws the algorithm in use:
{{{
#include "core\GraphAlgorithms.h"

TEST(GraphTopologicalSort, simpleGraph)
{
   MockGraph graph;
   graph.addNode( MockNode() );
   graph.addNode( MockNode() );
   graph.addNode( MockNode() );
   graph.addNode (MockNode() );
   graph.connect( 0, 1 );
   graph.connect( 0, 2 );
   graph.connect( 2, 1 );
   graph.connect( 1, 3 );

   std::vector< MockGraph::Index > result;
   GraphTopologicalSort( result, graph );

   CPPUNIT_ASSERT_EQUAL( (unsigned int)4, result.size() );
   CPPUNIT_ASSERT_EQUAL( 0, result[0] );
   CPPUNIT_ASSERT_EQUAL( 2, result[1] );
   CPPUNIT_ASSERT_EQUAL( 1, result[2] );
   CPPUNIT_ASSERT_EQUAL( 3, result[3] );
}
}}}

  _IMPORTANT_ - the graph can't be a *DAG*. If the algorithm encounters a cycle in the graph, it will throw an exception.

  * `GraphDijkstra` - it's an implementation of the *Dijkstra algorithm* for pruning obsolete branches from the graph and creating a simpler graph with shortest possible paths between all of its nodes. 

  Here's a unit test presenting its usage:

{{{
#include "core\GraphAlgorithms.h"

TEST(GraphDijkstra, simpleGraph)
{
   MockGraph graph;
   graph.addNode(MockNode());
   graph.addNode(MockNode());
   graph.addNode(MockNode());
   graph.addNode(MockNode());
   graph.connect(0, MockEdge(1, 1));
   graph.connect(0, MockEdge(2, 2));
   graph.connect(2, MockEdge(1, 5));
   graph.connect(1, MockEdge(3, 3));

   MockGraph result;
   GraphDijkstra(result, graph, 0);

   CPPUNIT_ASSERT_EQUAL((unsigned int)3, result.getEdgesCount());

   CPPUNIT_ASSERT(result.getEdgeIdx(0, 1) != MockGraph::InvalidIndex);
   CPPUNIT_ASSERT_EQUAL(1, result.getEdge(result.getEdgeIdx(0, 1)).cost);

   CPPUNIT_ASSERT(result.getEdgeIdx(0, 2) != MockGraph::InvalidIndex);
   CPPUNIT_ASSERT_EQUAL(2, result.getEdge(result.getEdgeIdx(0, 2)).cost);

   CPPUNIT_ASSERT(result.getEdgeIdx(1, 3) != MockGraph::InvalidIndex);
   CPPUNIT_ASSERT_EQUAL(3, result.getEdge(result.getEdgeIdx(1, 3)).cost);

}
}}}

==Graph builder==

It allows you to create simple graph definitions and is a proxy between a `Graph` and how the rest of the `RTTI` aware system can access it.

===Rationale===

`Graph` on its own is a handy programming tool, but it blend well if we were to serialize it or provide it with RTTI etc.
The reason is that it's a templated class, deprived of all unnecessary things and made that way just so that we can quickly run some algorithms on it.

If we actually want to create graphs we'll be able to serialize, expose to the editor etc, we require a different tool:
  * it should operate on arbitrary nodes and edges ( which could be RTTI `Objects` )
  * it should be able to serialize them
  * we should be able to put it in a `Resource` 
  * other `Resources` should be able to store pointers to its nodes and edges
  * we should be able to pass data between the nodes via the edges.

And altough the first point is fulfilled by the `Graph` class, the rest are not, or can't be done in an easy way.

===Components===

  * `GraphBuilder` - represents a graph. It contains a method `buildGraph` that allows you to instantiate a `Graph` instance.

  * `GraphBuilderNode` - represents a graph node. It can contain a number of named input and output sockets that define how many incoming and outgoing edges a node can have.

  * `GBNodeOutput` - a socket from which a graph edge starts. It can have some data associated with it. The real strength lies in the fact that the parent node *knows* about this socket and it can access it.

  * `GBNodeInput` - a socket where a graph edge ends. It *knows* what input socket it is connected to and can access it, and the parent node knows about this socket.

All classes are template classes, meaning that you can define what custom implementations they'll be representing, and not worry about casting.


===Data propagation===

About the sockets - it's a powerfull mechanism that allows to exchange data between the nodes.
So the graph can now not only be used to represent some static data, but can actually *propagate* data.

How can you achieve that? Well - basic definitions don't provide that functionality, however if you chose to have it, you can create implementations that:
  * have a data setter and getter on the output node - and the parent node can set the data.
  * have a counterpart input node that can connect only with the proper output ( you can define what output can be connected to an input by overriding the `GBNodeInput::canConnect` method ).
  * have a getter method on the custom input the parent block can query, and which in turn queries the data from the input.

[RendererCore#Rendering_pipeline Rendering pipeline] and a few other implementations use that data propagation mechanism - check it out.


===How to use it===

As I mentioned, the base classes are templates, and are not `RTTI` oriented ( except for the sockets - but those are not registered and are objects just to provide future RTTI capabilites from the base class ).

*COMMENT*: For simplicity sake, I'll skip all additional functionalities and describe the skeleton you have to define in order to get your graph resources up and running.

First of all you need to define your own `GraphBuilder` class, like so:

{{{
// ------------------------- .h file ------------------------------
#pragma once

#include "core/Resource.h"
#include "core/GraphBuilder.h"
#include <vector>


///////////////////////////////////////////////////////////////////////

class MyGraphNode;

///////////////////////////////////////////////////////////////////////

class MyGraphBuilder: public Resource, public GraphBuilder< MyGraphBuilder, MyGraphNode>
{
   DECLARE_RESOURCE( MyGraphBuilder);

public:
   /**
    * Constructor.
    *
    * @param resourceName   name of the resource file
    */
   MyGraphBuilder( const FilePath& resourceName = FilePath() );

protected:
   // -----------------------------------------------------------------
   // GraphBuilder implementation
   // -----------------------------------------------------------------
   void onNodeAdded( MyGraphNode* node );
   void onNodeRemoved( MyGraphNode& node );
};

// ------------------------- .cpp file ------------------------------

///////////////////////////////////////////////////////////////////////

BEGIN_RESOURCE( MyGraphBuilder, Resource, myres, AM_BINARY );
   PROPERTY( std::vector< MyGraphNode* >, m_nodes );
   // ... your own additional properties go here
END_RESOURCE();

///////////////////////////////////////////////////////////////////////

MyGraphBuilder::MyGraphBuilder( const FilePath& resourceName )
   : Resource( resourceName )
{
}

///////////////////////////////////////////////////////////////////////

void MyGraphBuilder::onNodeAdded( MyGraphNode* node )
{
   addObject( node );
}

///////////////////////////////////////////////////////////////////////

void MyGraphBuilder::onNodeRemoved( MyGraphNode& node )
{
   removeObject( node.getObjectId() );
}

///////////////////////////////////////////////////////////////////////

// ------------------- Type registration file ------------------------

REGISTER_RTTI( MyGraphBuilder );
}}}


Next - you have to define your node:

{{{
// ------------------------- .h file ------------------------------
#pragma once

#include "core/Resource.h"
#include "core/GraphBuilderNode.h"
#include "MySockets.h"


///////////////////////////////////////////////////////////////////////

class MyGraphNode: public ResourceObject, public GraphBuilderNode< MyGraphNode, MyNodeInput, MyNodeOutput >
{
   DECLARE_CLASS( MyGraphNode)

public:
   virtual ~MyGraphNode() {}

   // -----------------------------------------------------------------
   // Object implementation
   // -----------------------------------------------------------------
   void onObjectLoaded();
   void onPropertyChanged( Property& property );
};

///////////////////////////////////////////////////////////////////////

// ------------------------- .cpp file ------------------------------

///////////////////////////////////////////////////////////////////////

BEGIN_ABSTRACT_OBJECT( MyGraphNode, ResourceObject );
   PROPERTY( InputsMap, m_inputs );
   PROPERTY( OutputsMap, m_outputs );
   // custom node properties go here
END_OBJECT();

///////////////////////////////////////////////////////////////////////

void MyGraphNode::onObjectLoaded()
{
   __super::onObjectLoaded();

   onBulkSocketsInitialization();
}

///////////////////////////////////////////////////////////////////////

void MyGraphNode::onPropertyChanged( Property& property )
{
   __super::onPropertyChanged( property );

   if ( property.getName() == "m_inputs" )
   {
      notify( GBNO_INPUTS_CHANGED );
   }
   else if ( property.getName() == "m_outputs" )
   {
      notify( GBNO_OUTPUTS_CHANGED );
   }
   else
   {
      notify( GBNO_CHANGED );
   }
}

///////////////////////////////////////////////////////////////////////

// ------------------- Type registration file ------------------------

REGISTER_RTTI( MyGraphNode );

}}}

And finally the sockets:

{{{
// ------------------------- .h file ------------------------------
#pragma once

#include "core/GraphBuilderSockets.h"
#include "core/Object.h"


///////////////////////////////////////////////////////////////////////

class MyGraphNode;

///////////////////////////////////////////////////////////////////////

/**
 * Output socket of a node.
 */
class MyNodeOutput : public GBNodeOutput< MyGraphNode>
{
   DECLARE_CLASS( MyNodeOutput )

public:
   /**
    * Constructor.
    *
    * @param name
    */
   MyNodeOutput ( const std::string& name = "" );
   virtual ~MyNodeOutput() {}
};

///////////////////////////////////////////////////////////////////////

/**
 * Input socket of a node.
 */
class MyNodeInput : public GBNodeInput< MyNodeOutput >
{
   DECLARE_CLASS( MyNodeInput )

public:
   /**
    * Constructor.
    *
    * @param name
    */
   MyNodeInput( const std::string& name = "" );
   virtual ~MyNodeInput() {}
};

///////////////////////////////////////////////////////////////////////

// ------------------------- .cpp file ------------------------------

///////////////////////////////////////////////////////////////////////

BEGIN_ABSTRACT_OBJECT( MyNodeInput, Object );
   PROPERTY( std::string, m_name );
   PROPERTY( MyNodeOutput*, m_connectedOutput );
   // custom properties go here
END_OBJECT();

///////////////////////////////////////////////////////////////////////

MyNodeInput::MyNodeInput( const std::string& name )
   : GBNodeInput< MyNodeOutput >( name )
{
}

//////////////////////////////////////////////////////////////////////

BEGIN_ABSTRACT_OBJECT( MyNodeOutput, Object );
   PROPERTY( std::string, m_name );
   PROPERTY( std::vector< MyGraphNode* >, m_connectedNodes );
   // custom properties go here
END_OBJECT();

///////////////////////////////////////////////////////////////////////

MyNodeOutput::MyNodeOutput( const std::string& name )
   : GBNodeOutput< MyGraphNode >( name )
{
}

///////////////////////////////////////////////////////////////////////

// ------------------- Type registration file ------------------------

REGISTER_RTTI( MyNodeInput );
REGISTER_RTTI( MyNodeOutput);

}}}

===Creating simple graph in the builder===


First of all, we'll assume that we have our classes definitions created:

{{{
   class GBMockNode;
   class MockOutput : public GBNodeOutput< GBMockNode >
   {
   public:
      MockOutput() : GBNodeOutput< GBMockNode >( "Output" ) {}
   };

   // -----------------------------------------------------------------

   class MockInput : public GBNodeInput< MockOutput >
   {
   public:
      MockInput() : GBNodeInput< MockOutput >( "Input" ) {}

   protected:
      bool canConnect( MockOutput& output ) const { return true; }
   };

   // -----------------------------------------------------------------

   class GBMockNode : public GraphBuilderNode< GBMockNode, MockInput, MockOutput >
   {
   public:
      int         m_idx;

   public:
      GBMockNode( int idx ) : m_idx( idx ) {}
      virtual ~GBMockNode() {}
   };

   // -----------------------------------------------------------------

   class GBMStartNode : public GBMockNode
   {
   public:
      GBMStartNode( int idx ) : GBMockNode( idx ) 
      {
         defineOutput( new MockOutput() );
      }
   };

   // -----------------------------------------------------------------

   class GBMEndNode : public GBMockNode
   {
   public:
      GBMEndNode( int idx ) : GBMockNode( idx ) 
      {
         defineInput( new MockInput() );
      }
   };

   // -------------------------------------------------------------------------

   class GBMUtilNode : public GBMockNode
   {
   public:
      int         m_idx;

   public:
      GBMUtilNode( int idx ) : GBMockNode( idx )
      {
         defineInput( new MockInput() );
         defineOutput( new MockOutput() );
      }
   };

   // -----------------------------------------------------------------

   class GraphBuilderMock : public GraphBuilder< GraphBuilderMock, GBMockNode >
   {
   public:
      // --------------------------------------------------------------
      // GraphBuilder implementation
      // --------------------------------------------------------------
      void onNodeAdded( GBMockNode* node ) {}
      void onNodeRemoved( GBMockNode& node ) {}
   };
}}}

As you can see, here we have 3 node types:
  * Start ( with one output called "Output" )
  * Util ( with an input called "Input" and an output called "Output" )
  * End ( with on input called "Input" )

Let's connect them in a simple manner:

{{{
GraphBuilderMock builder;

GBMockNode* node[] = { new GBMStartNode( 0 ), new GBMUtilNode( 1 ), new GBMEndNode( 2 ) };

builder.addNode( node[0] );
builder.addNode( node[1] );
builder.addNode( node[2] );

node[0]->connect( "Output", node[1], "Input" );
node[1]->connect( "Output", node[2], "Input" );
}}}


Method `GraphBuilderNode::connect` facilitates creating connection between two nodes. Simply specify the output of the original node, the target node and its input we want to connect to, and the connection will be established.


Whenever you want to disconnect two nodes, you can use the `GraphBuilderNode::disconnect` method:
{{{
/**
 * Disconnects this node from the specified node's input.
 *
 * @param destNode
 * @param inputName
 */
void disconnect( Impl& destNode, const std::string& inputName );
}}}