#labels renderer
=Renderer=

A renderer allows to render 3D graphics on screen. It takes care of managing the device's state, finding out about best texture formats etc.

To get it to work, you only need to instantiate a renderer and set a `RenderingMechanism`, that will start feeding the renderer some `RenderCommands` and that's it.

A renderer can't work on its own however - it requres an underlying library it will execute the commands on and bring images to life.

At this moment, the only imlementation that exists uses DirectX9, but there will be more.

==Core functionality==

As mentioned, the nuts and bolts lie in the `RenderingMechanism` and in a `RenderCommand`.

A renderer instance can use only one `RenderingMechanism` at a time and it manages its lifetime.
You can set it using `Renderer.setMechanism` method:

{{{
renderer.setMechanism( new MyRenderMechanism() );
}}}

The mechanism has a 3 methods in its interface:
{{{
class RenderingMechanism
{
public:
   virtual ~RenderingMechanism() {}

   /**
    * Initializes the mechanism with the renderer that will be using it.
    *
    * @param renderer
    */
   virtual void initialize( Renderer& renderer ) = 0;

   /**
    * Deinitializes the mechanism with the renderer that was using it.
    *
    * @param renderer
    */
   virtual void deinitialize( Renderer& renderer ) = 0;

   /**
    * Performs the rendering operation defined by the mechanism.
    *
    * @param renderer
    */
   virtual void render( Renderer& renderer ) = 0;
};
}}}

Each time the mechanism is set for the first time, `initialize` method will be called. And whenever it's about to be destroyed, the renderer will call the `deinitialize` method.

Each time the renderer wants the mechanism to render something, it will call its `render` command.

The parameter passed to the mechanism is the instance of the renderer.
The renderer instance, among other methods, exposes a very important one - `operator()`, which gives you access to the `RenderCommand` buffer and allows you to queue render commands:

{{{

void MyRenderMechanism::render( Renderer& renderer )
{
   // ...

   new ( renderer() ) new RCBindPixelShader( *m_shader );
   new ( renderer() ) new RCUnbindPixelShader( *m_shader );

   // ...
}

}}}

==Render commands==

Render commands are a way of telling the underlying library what to do.
They are responsible for:
 * setting up shaders
 * drawing geoemtry
 * setting up render targets
 * retriving colors from a render surface
and many many more.

Basically, you can write your own commands you require, write their implementations in the renderer implementation library and you can start using them in your own mechanisms.

==Geometry==

===Vertex shaders output structure===

{{{
struct VS_OUTPUT
{
    float4 Position     : POSITION;   // vertex position 
    float4 Diffuse      : COLOR0;     // vertex diffuse color (note that COLOR0 is clamped from 0..1)
    float2 TextureUV    : TEXCOORD0;  // vertex texture coords 
    float3 Normal       : TEXCOORD1;  // vertex normal
    float3 ViewPosition : TEXCOORD2;  // vertex view position
};
}}}

==Materials==

==Debug renderer==

==Rendering pipeline==


==Camera==